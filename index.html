<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
    <title>ç²’å­ä¿¡æ¯åˆ†äº« - æ‰‹æœºå‹å¥½ç‰ˆ</title>
    <style>
        :root { --primary: #00ffff; --bg: #050505; }
        body { margin: 0; overflow: hidden; background: var(--bg); font-family: sans-serif; color: white; }
        
        #ui-container {
            /* æ‰‹æœºä¼˜åŒ–ï¼šæ”¾åœ¨å±å¹•åº•éƒ¨ï¼Œå®½åº¦å æ»¡ */
            position: fixed; bottom: 0; left: 0; right: 0; 
            max-width: 100vw; /* ç¡®ä¿ä¸è¶…å‡ºå±å¹• */
            background: rgba(0,0,0,0.8); 
            backdrop-filter: blur(10px);
            padding: 10px; /* è°ƒæ•´å†…è¾¹è· */
            border-top-left-radius: 12px; 
            border-top-right-radius: 12px;
            border: 1px solid rgba(255,255,255,0.1);
            user-select: none; z-index: 10;
            display: flex; flex-direction: column; /* å‚ç›´å †å  */
        }

        /* æ¡Œé¢ç«¯éšè—ï¼Œæ‰‹æœºç«¯æ˜¾ç¤º */
        @media (min-width: 600px) {
            #ui-container {
                /* æ¡Œé¢ç«¯æ¢å¤åˆ°å³ä¸Šè§’ */
                position: absolute; top: 20px; right: 20px; width: 280px; 
                bottom: auto; left: auto;
                border-radius: 12px;
            }
        }
        
        /* è¾“å…¥åŒºåŸŸæ ·å¼ */
        .input-group { display: flex; gap: 5px; margin-bottom: 10px; }
        input[type="text"] {
            flex: 1; padding: 8px; border-radius: 4px; border: 1px solid #333;
            background: rgba(255,255,255,0.1); color: white; outline: none;
        }
        #btn-submit { background: var(--primary); color: black; font-weight: bold; border: none; cursor: pointer; padding: 0 15px; border-radius: 4px; }
        
        button {
            flex: 1; /* æŒ‰é’®å¹³å‡åˆ†é…å®½åº¦ */
            padding: 8px; margin: 3px; background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2); color: #ddd; border-radius: 4px;
            cursor: pointer; transition: 0.2s; font-size: 12px;
        }
        button:hover { background: var(--primary); color: black; }
        button.active { background: var(--primary); color: black; font-weight: bold; }
        
        .button-row { display: flex; margin-bottom: 5px; }

        #loading { position: absolute; inset: 0; background: #000; z-index: 99; display: flex; align-items: center; justify-content: center; color: var(--primary); letter-spacing: 2px; }
        #webcam { position: absolute; bottom: 20px; left: 20px; width: 100px; opacity: 0.3; transform: scaleX(-1); pointer-events: none; border: 1px solid var(--primary); }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>
</head>
<body>
    <div id="loading">ç³»ç»Ÿåˆå§‹åŒ–ä¸­...</div>

    <div id="ui-container">
        <div class="input-group">
            <input type="text" id="user-text" placeholder="è¾“å…¥åå­—/è‹±æ–‡..." maxlength="8">
            <button id="btn-submit" onclick="app.generateText()">ç”Ÿæˆ</button>
        </div>

        <div class="button-row">
            <button onclick="app.setShape('sphere')" id="btn-sphere" class="active">çƒä½“</button>
            <button onclick="app.setShape('cube')" id="btn-cube">ç«‹æ–¹</button>
            <button onclick="app.loadLogo('logo.png')" id="btn-logo">ğŸ”´ Logoå›¾</button>
        </div>
        
        <div class="button-row">
            <button onclick="app.toggleAudio()" id="btn-audio">ğŸµ å¼€å¯éŸ³ä¹å¾‹åŠ¨</button>
        </div>
    </div>

    <video id="webcam" autoplay playsinline muted></video>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // Shader ä»£ç  (ä¿æŒç¨³å®šç‰ˆ v3.3)
        const vertexShader = `
            uniform float uTime; uniform float uMixFactor; uniform float uExplode; uniform float uAudioLevel;
            attribute vec3 aTargetPos; attribute vec3 aOriginalColor; varying vec3 vColor;
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; } vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; } vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); } vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; } float snoise(vec3 v) { const vec2 C = vec2(1.0/6.0, 1.0/3.0) ; const vec4 D = vec4(0.0, 0.5, 1.0, 2.0); vec3 i = floor(v + dot(v, C.yyy) ); vec3 x0 = v - i + dot(i, C.xxx) ; vec3 g = step(x0.yzx, x0.xyz); vec3 l = 1.0 - g; vec3 i1 = min( g.xyz, l.zxy ); vec3 i2 = max( g.xyz, l.zxy ); vec3 x3 = x0 - D.yyy; i = mod289(i); vec4 p = permute( permute( permute( i.z + vec4(0.0, i1.z, i2.z, 1.0 )) + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) + i.x + vec4(0.0, i1.x, i2.x, 1.0 )); float n_ = 0.142857142857; vec3 ns = n_ * D.wyz - D.xzx; vec4 j = p - 49.0 * floor(p * ns.z * ns.z); vec4 x_ = floor(j * ns.z); vec4 y_ = floor(j - 7.0 * x_ ); vec4 x = x_ *ns.x + ns.yyyy; vec4 y = y_ *ns.x + ns.yyyy; vec4 h = 1.0 - abs(x) - abs(y); vec4 b0 = vec4( x.xy, y.xy ); vec4 b1 = vec4( x.zw, y.zw ); vec4 s0 = floor(b0)*2.0 + 1.0; vec4 s1 = floor(b1)*2.0 + 1.0; vec4 sh = -step(h, vec4(0.0)); vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ; vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ; vec3 p0 = vec3(a0.xy,h.x); vec3 p1 = vec3(a0.zw,h.y); vec3 p2 = vec3(a1.xy,h.z); vec3 p3 = vec3(a1.zw,h.w); vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3))); p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w; vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0); m = m * m; return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) ); }
            void main() {
                if (length(aOriginalColor) < 0.1) { vColor = vec3(0.0, 1.0, 0.8); } else { vColor = aOriginalColor; }
                vec3 mixedPos = mix(position, aTargetPos, uMixFactor);
                float noise = snoise(mixedPos * 0.1 + uTime * 0.5);
                mixedPos += noise * 0.5;
                mixedPos *= 1.0 + (uAudioLevel * 0.3 * noise);
                vec3 dir = normalize(mixedPos);
                mixedPos += dir * uExplode * 10.0;
                vec4 mvPosition = modelViewMatrix * vec4(mixedPos, 1.0);
                gl_Position = projectionMatrix * mvPosition;
                gl_PointSize = (2.5 + uAudioLevel * 8.0) * (100.0 / -mvPosition.z);
            }
        `;
        const fragmentShader = `varying vec3 vColor; void main() { float d = distance(gl_PointCoord, vec2(0.5)); if(d>0.5) discard; float strength = pow(1.0-(d*2.0), 3.0); gl_FragColor = vec4(vColor, strength); }`;

        class ParticleApp {
            constructor() {
                this.container = document.body; 
                // ã€å…³é”®æ”¹åŠ¨ã€‘é™ä½é»˜è®¤ç²’å­æ•°ä»¥é€‚åº”æ‰‹æœº
                this.particleCount = 15000; 
                this.currentShape = 'sphere';
                this.handOpenness = 1.0; this.audioLevel = 0;
                this.initThree(); this.initParticles(); this.initMediaPipe();
                this.animate = this.animate.bind(this); 
                this.onWindowResize = this.onWindowResize.bind(this);
                window.addEventListener('resize', this.onWindowResize); // ç›‘å¬çª—å£å˜åŒ–
                requestAnimationFrame(this.animate);
            }
            
            // ã€å…³é”®æ”¹åŠ¨ã€‘æ·»åŠ çª—å£å¤§å°è°ƒæ•´å‡½æ•°ï¼Œé€‚åº”æ‰‹æœºæ¨ªç«–å±åˆ‡æ¢
            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.composer.setSize(window.innerWidth, window.innerHeight);
            }

            initThree() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.z = 30;
                this.renderer = new THREE.WebGLRenderer({ antialias: false });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.container.appendChild(this.renderer.domElement);
                // OrbitControls é»˜è®¤æ”¯æŒé¼ æ ‡å’Œè§¦æ‘¸ï¼ˆæ‰‹æŒ‡æ‹–åŠ¨ï¼‰ï¼Œè¿™æ˜¯å…¼å®¹æ‰‹æœºçš„å…³é”®
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true; this.controls.autoRotate = false;
                this.composer = new EffectComposer(this.renderer);
                this.composer.addPass(new RenderPass(this.scene, this.camera));
                this.composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.4, 0.4, 0.6));
            }

            initParticles() {
                this.geometry = new THREE.BufferGeometry(); this.updateParticleCount(this.particleCount);
                this.material = new THREE.ShaderMaterial({
                    vertexShader, fragmentShader,
                    uniforms: { uTime: { value: 0 }, uMixFactor: { value: 0 }, uExplode: { value: 0 }, uAudioLevel: { value: 0 } },
                    transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
                });
                this.points = new THREE.Points(this.geometry, this.material); this.scene.add(this.points);
                this.targets = { sphere: this.generateSphere(this.particleCount), cube: this.generateCube(this.particleCount) };
                this.setShape('sphere');
            }

            updateParticleCount(count) {
                const p = new Float32Array(count * 3); const t = new Float32Array(count * 3); const c = new Float32Array(count * 3);
                for (let i = 0; i < count; i++) {
                    p[i*3]=(Math.random()-0.5)*50; p[i*3+1]=(Math.random()-0.5)*50; p[i*3+2]=(Math.random()-0.5)*50;
                    c[i*3]=0;
                }
                this.geometry.setAttribute('position', new THREE.BufferAttribute(p, 3));
                this.geometry.setAttribute('aTargetPos', new THREE.BufferAttribute(t, 3));
                this.geometry.setAttribute('aOriginalColor', new THREE.BufferAttribute(c, 3));
            }

            generateText() {
                const input = document.getElementById('user-text');
                const text = input.value.trim();
                if(!text) return;

                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 400; canvas.height = 200; 
                
                ctx.fillStyle = 'black'; ctx.fillRect(0,0,400,200);
                ctx.fillStyle = '#ff0055'; 
                ctx.font = 'bold 120px Arial';
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(text, 200, 100);

                const data = ctx.getImageData(0,0,400,200).data;
                const pts = [];
                for(let i=0; i<data.length; i+=4) {
                    if(data[i] > 50) { 
                        pts.push({ x: (i/4)%400, y: Math.floor((i/4)/400) });
                    }
                }

                if(pts.length === 0) { alert("æ–‡å­—å¤ªç»†æˆ–å¤ªå°ï¼Œæ— æ³•ç”Ÿæˆç²’å­"); return; }

                const td = new Float32Array(this.particleCount*3);
                const cd = this.geometry.attributes.aOriginalColor.array;
                
                for(let i=0; i<this.particleCount; i++) {
                    const p = pts[i % pts.length];
                    const scale = 0.1; 
                    td[i*3] = (p.x - 200) * scale;
                    td[i*3+1] = -(p.y - 100) * scale;
                    td[i*3+2] = 0;
                    cd[i*3] = 1.0; cd[i*3+1] = 0.0; cd[i*3+2] = 0.5;
                }
                this.geometry.attributes.aOriginalColor.needsUpdate = true;
                this.targets['text'] = td;
                this.setShape('text');
                
                document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            }

            loadLogo(url) {
                const img = new Image(); img.src = url; img.crossOrigin = "Anonymous";
                img.onload = () => {
                    const c = document.createElement('canvas'); const ctx = c.getContext('2d');
                    let w = img.width, h = img.height; const max=250; if(w>max){h=Math.round(h*(max/w));w=max;}
                    c.width=w; c.height=h; ctx.drawImage(img,0,0,w,h);
                    const d = ctx.getImageData(0,0,w,h).data; const pts = [];
                    for(let i=0;i<d.length;i+=4) { if(!(d[i]>220&&d[i+1]>220&&d[i+2]>220)) pts.push({x:i/4%w, y:Math.floor(i/4/w), c:[d[i]/255,d[i+1]/255,d[i+2]/255]}); }
                    const td = new Float32Array(this.particleCount*3); const cd = this.geometry.attributes.aOriginalColor.array;
                    for(let i=0;i<this.particleCount;i++) {
                        const p = pts[i%pts.length]; const s=16.0;
                        td[i*3]=(p.x/w-0.5)*s; td[i*3+1]=-(p.y/h-0.5)*s*(h/w); td[i*3+2]=0;
                        cd[i*3]=p.c[0]; cd[i*3+1]=p.c[1]; cd[i*3+2]=p.c[2];
                    }
                    this.geometry.attributes.aOriginalColor.needsUpdate = true;
                    this.targets['logo'] = td; this.setShape('logo');
                    document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
                    document.getElementById('btn-logo').classList.add('active');
                };
            }

            setShape(shape) {
                this.currentShape = shape; const t = this.targets[shape]; const attr = this.geometry.attributes.aTargetPos;
                if(shape!=='logo' && shape!=='text') { 
                    const c = this.geometry.attributes.aOriginalColor.array; 
                    for(let i=0;i<c.length;i++) c[i]=0; 
                    this.geometry.attributes.aOriginalColor.needsUpdate = true; 
                }
                for(let i=0;i<t.length;i++) attr.array[i] = t[i];
                attr.needsUpdate = true; this.material.uniforms.uMixFactor.value = 0;

                // æ¿€æ´»å½“å‰æŒ‰é’®
                document.querySelectorAll('.button-row button').forEach(b => {
                    if (b.id === `btn-${shape}`) {
                        b.classList.add('active');
                    } else if (b.id.startsWith('btn-') && b.id !== 'btn-audio') {
                        b.classList.remove('active');
                    }
                });
            }

            generateSphere(count) { const d=new Float32Array(count*3); for(let i=0;i<count;i++){const r=6*Math.cbrt(Math.random());const t=Math.random()*2*Math.PI;const p=Math.acos(2*Math.random()-1);d[i*3]=r*Math.sin(p)*Math.cos(t);d[i*3+1]=r*Math.sin(p)*Math.sin(t);d[i*3+2]=r*Math.cos(p);} return d;}
            generateCube(count) { const d=new Float32Array(count*3); for(let i=0;i<count;i++){d[i*3]=(Math.random()-0.5)*8;d[i*3+1]=(Math.random()-0.5)*8;d[i*3+2]=(Math.random()-0.5)*8;} return d;}
            async initMediaPipe() { const v = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"); this.hl = await HandLandmarker.createFromOptions(v, { baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" }, runningMode: "VIDEO", numHands: 1 }); navigator.mediaDevices.getUserMedia({ video: true }).then((s) => { const el = document.getElementById('webcam'); el.srcObject = s; el.addEventListener('loadeddata', () => { document.getElementById('loading').style.display = 'none'; this.loop(); }); }); }
            loop() { const el=document.getElementById('webcam'); if(el.currentTime>0){const res=this.hl.detectForVideo(el,performance.now()); if(res.landmarks[0]){const lm=res.landmarks[0];const tips=[8,12,16,20];let d=0;tips.forEach(i=>d+=Math.sqrt(Math.pow(lm[i].x-lm[0].x,2)+Math.pow(lm[i].y-lm[0].y,2)));this.handOpenness+=((d/4>0.3?1:0)-this.handOpenness)*0.1;}else{this.handOpenness+=(1-this.handOpenness)*0.05;}} requestAnimationFrame(()=>this.loop()); }
            toggleAudio() { if(this.ac)return; this.ac=new(window.AudioContext||window.webkitAudioContext)(); navigator.mediaDevices.getUserMedia({audio:true}).then(s=>{const src=this.ac.createMediaStreamSource(s);this.an=this.ac.createAnalyser();this.an.fftSize=256;src.connect(this.an);document.getElementById('btn-audio').innerText="ğŸ¤ è†å¬ä¸­...";}); }
            animate() { requestAnimationFrame(this.animate); const t=performance.now()*0.001; this.material.uniforms.uTime.value=t; if(this.material.uniforms.uMixFactor.value<1)this.material.uniforms.uMixFactor.value+=0.02; const target=(1.0-this.handOpenness); this.material.uniforms.uExplode.value+=(target-this.material.uniforms.uExplode.value)*0.1; if(this.an){const d=new Uint8Array(this.an.frequencyBinCount);this.an.getByteFrequencyData(d);let a=0;for(let i=0;i<d.length;i++)a+=d[i];this.audioLevel=a/d.length/255;this.material.uniforms.uAudioLevel.value=this.audioLevel;} this.controls.update(); this.composer.render(); }
        }
        window.app = new ParticleApp();
    </script>
</body>
</html>